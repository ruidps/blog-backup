{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"服务监控","text":"","link":"/status/index.html"},{"title":"Links","text":"🤙Ring a ring a ring~ ps:以下排名不分先后 程序萌部落编程, NAS, 吃喝玩乐学 ZidoneStudent & Engineer MuJin’s Blog君浅吟，叹落笔 霓红的博客As bright as neon. initcool不选大的怎么能赢 无名小筑一只咸鱼的日常 杏铃の小本一份分享教程,游戏的礼物✧(≖ ◡ ≖✿) GivenSir说不定是未来的架构师，也说不定送外卖的程序员。 零奇部落格零奇部落格 Dejavu's Blog与君初相见，犹如故人归 北枫北枫生活 江江江的三言两语 御网尚书 源自于热爱网络安全 CtrlCV博客 一顿CV猛如虎. 友链申请 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请链接前请先添加本博链接，通过留言告知。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 会定期清理不符合要求的友链，不再另行通知。 本站信息1234- 名称：Rui's Blog- 描述：有好玩的带上我xD- 链接：https://blog.rui.plus- 头像：https://q1.qlogo.cn/g?b=qq&amp;nk=1034958019&amp;s=640","link":"/links/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/hello-world/"},{"title":"FORBIDDEN&#x2F;12&#x2F;index read-only &#x2F; allow delete (api)-Elasticsearch&#x2F;Logstash错误","text":"logstash日志中显示 [FORBIDDEN/12/index read-only / allow delete (api)] logstash无法向elasticsearch写入文档，原因大致是硬盘已满导致。 硬盘已满时elasticsearch由于没有空间无法索引更多的文档，而将自己切换为只读状态，以确保只读查询的可用性。 此时无法写入，且增加/清理空间后也不会自动恢复。 可以发送以下命令来手动关闭elasticsearch的只读状态 1curl -XPUT -H &quot;Content-Type: application/json&quot; http://localhost:9200/_all/_settings -d '{&quot;index.blocks.read_only_allow_delete&quot;: null}' 如果使用docker将elk安装在一个系统中，可能因为logstash日志过多而塞满硬盘导致以上问题。 使用下面脚本清理docker的日志 12345678echo &quot;======== start clean docker containers logs ========&quot;logs=$(find /var/lib/docker/containers/ -name *-json.log)for log in $logs do echo &quot;clean logs : $log&quot; cat /dev/null &gt; $log doneecho &quot;======== end clean docker containers logs ========&quot;","link":"/2021/2021-7-15/"},{"title":"logstash切割日志案例-grok、kv、ruby使用","text":"近期时间主要都在研究elk三件套，既elasticsearch，logstash和kibana 记录一个日志过滤的案例 实际数据有部分删减, 原日志： 1&lt;186&gt;1 2021-07-05T08:51:57.198+08:00 iMaster NCE ALARM - AC-004 [alarm resource=&quot;OID=1.1.1.1.1.1.1;index=xxxxxxxxxxxxxxxxxxx;ESN=xxxxxxxxxxxxxx&quot; probableCause=&quot;与远端站点建立的BGP协议中断。&quot; perceivedSeverity=MAJOR&quot; eventType=&quot;OTHER&quot; resourceURI=&quot;/devices/e7257a97fc1a&quot;] alarmId=&quot;66666&quot; alarmName=&quot;&quot; alarmType=&quot;0&quot; occurTime=&quot;2021-07-05 08:52:00&quot; locationInfo=&quot;OID=1.1.1.1.1.1.1;index=xxxxxxxxxxxxxxxxxxx;ESN=xxxxxxxxxxxxxx&quot; additionInfo=&quot;The connection has entered the down state. (ConnectionID = 111; SrcTNPID = 111; DestSiteID = 111; DestTNPID = 111)&quot; type=&quot;Alarm&quot; 首先使用grok对日志进行初步的切割grok { patterns_dir =&gt; [&quot;/usr/share/logstash/conf.d/patterns&quot;] match =&gt; { &quot;message&quot; =&gt; &quot;%{DATA:head}%{TIMESTAMP_ISO8601:timestamp}%{TEMP1:temp1}%{ALARM:alarm}%{TEMP2:temp2}%{TOEND:toend}&quot; } } 其中patterns为简单的正则 1234TEMP1 \\s.*?\\[alarm\\sALARM [\\S\\s]*TEMP2 \\]\\sTOEND [\\s\\S]* 匹配到数据后会按顺序放在对应的字段中，logstash的配置文件也是顺序执行的，多个插件使用时按顺序放配置就好。 grok的自定义规则可以使用kibana中的开发者工具快速的进行测试，不然每次写好都运行一次logstash-非常麻烦 例如其中匹配到的alarm字段的值为 1resource=&quot;OID=1.1.1.1.1.1.1;index=xxxxxxxxxxxxxxxxxxx;ESN=xxxxxxxxxxxxxx&quot; probableCause=&quot;与远端站点建立的BGP协议中断。&quot; perceivedSeverity=MAJOR&quot; eventType=&quot;OTHER&quot; resourceURI=&quot;/devices/e7257a97fc1a&quot; 因为特征非常明显，所以可以直接使用kv插件进行匹配 使用kv插件配置文件 kv { source=&gt; &quot;alarm&quot; trim_value =&gt; &quot;\\&quot;&quot; } 此处就是取出alarm字段自动处理，就可以得到一个个键值对信息。 toend字段的处理与alarm一致 使用ruby插件因为有一部分内容的格式不固定，所以使用ruby插件来处理，ruby插件其实就是使用ruby语言编写字符串(数据)处理脚本。 …这也是我也是第一次接触ruby语言 conf配置如下 ruby { path =&gt; &quot;/usr/share/logstash/conf.d/additionInfo.rb&quot; } ruby脚本如下 1234567def filter(event) _additionInfo = event.get('additionInfo') event.set(&quot;device_id&quot;,event.get('resourceURI').split(&quot;/&quot;).last) # ......中间省略了很多，主要就是必须有一个filter方法，可以使用event操作logstash的字段，最终返回一个event对象 event.set(&quot;type_zh&quot;,_type) return [event]end 使用mutate删除多余的字段最后删除多余的字段就可以了 mutate { remove_field =&gt; [&quot;head&quot;,&quot;temp1&quot;,&quot;temp2&quot;,&quot;alarm&quot;] } 完整的脚本如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677input { #beats { #port =&gt; 5044 #codec =&gt; &quot;json&quot; # } elasticsearch { schedule =&gt; &quot;* * * * *&quot; hosts =&gt; &quot;0.0.0.0:9200&quot; index =&gt; &quot;huawei-sdwan&quot; user =&gt; &quot;bothwin&quot; password =&gt; &quot;both-win&quot; docinfo =&gt; true docinfo_fields =&gt; [&quot;_id&quot;,&quot;@timestamp&quot;] query =&gt; '{&quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;range&quot;: { &quot;@timestamp&quot;: { &quot;gte&quot;: &quot;now/d&quot;, &quot;lt&quot;: &quot;now+1d/d&quot; } } },{ &quot;match&quot;: { &quot;message&quot;: &quot;probableCause&quot; } } ], &quot;should&quot;: [] } }}' }}filter { fingerprint { source =&gt; [&quot;message&quot;] target =&gt; &quot;[@metadata][generated_id]&quot; method =&gt; &quot;SHA256&quot; key =&gt; &quot;fuhb&quot; concatenate_sources =&gt; true } grok { patterns_dir =&gt; [&quot;/usr/share/logstash/conf.d/patterns&quot;] match =&gt; { &quot;message&quot; =&gt; &quot;%{DATA:head}%{TIMESTAMP_ISO8601:timestamp}%{TEMP1:temp1}%{ALARM:alarm}%{TEMP2:temp2}%{TOEND:toend}&quot; } } kv { source=&gt; &quot;alarm&quot; trim_value =&gt; &quot;\\&quot;&quot; } kv { source=&gt; &quot;toend&quot; default_keys =&gt; [ &quot;alarmName&quot;,&quot;&quot; ] } ruby { path =&gt; &quot;/usr/share/logstash/conf.d/additionInfo.rb&quot; } mutate { remove_field =&gt; [&quot;head&quot;,&quot;temp1&quot;,&quot;temp2&quot;,&quot;alarm&quot;] #测试时删除message字段 # remove_field =&gt; [&quot;toend&quot;] # remove_field =&gt; [&quot;timestamp&quot;,&quot;resource&quot;,&quot;perceivedSeverity&quot;,&quot;message&quot;] }}output { elasticsearch { hosts =&gt; [&quot;elasticsearch:9200&quot;] index =&gt; &quot;huawei-sdwan&quot; document_id =&gt; &quot;%{[@metadata][generated_id]}&quot; } stdout { codec =&gt; rubydebug }}","link":"/2021/2021-7-16/"},{"title":"快速制作博客logo","text":"前言众所周知啊，我的博客挂了很久了，前段时间一个下午就搭建好了，这其中自然也包括了制作logo的时间。 话不多说，直接开始教程，五分钟logo制作。 Google Fonthttps://fonts.google.com/ 首先，进入谷歌字体，Type something输入需要制作logo的字符。 然后你就可以预览到非常多的字体效果，有很多艺术字都很好看。 我知道很多人要说了，就这？不会直接叫人截图吧？ ps：直接截图也不是不行啊？ 我们知道icarus主题原来的logo是一个svg格式的图片，我们现在的目标也是获取一个svg格式的logo Google-Font-to-svg-pathhttps://github.com/danmarshall/google-font-to-svg-path 这里有一个项目，可以很方便的把google font你预览到的效果转换成svg格式 https://danmarshall.github.io/google-font-to-svg-path/ 上面是项目部署的网站 Svg Fill Stroke就差一点，就成功了，当然，如果你觉得镂空ok的话，就可以完工了。 说回svg，上面生成的svg是镂空的，需要编辑svg的代码，把 12&lt;g id=&quot;svgGroup&quot; stroke-linecap=&quot;round&quot; fill-rule=&quot;evenodd&quot; font-size=&quot;9pt&quot; stroke=&quot;#000&quot; stroke-width=&quot;0.25mm&quot; fill=&quot;none&quot; style=&quot;stroke: #ff0000;stroke-width:0.25mm;fill: #ff0000;&quot;&gt; &lt;!-- 上方style中的stroke 代表边框颜色，fill代表填充颜色 注意是g标签，当然你打开文件编辑后很容易可以发现--&gt; 如果你的字体图案有连笔，那么你填充颜色后会有空白，那你需要去网站重新生成svg文件(勾选union选项) 由于还没有，也并不打算花时间部署图片服务器，所以基本上不会有什么配图，自行理解吧。","link":"/2021/2021-7-20/"},{"title":"netdata简单部署及邮件配置","text":"安装netdata1bash &lt;(curl -Ss https://my-netdata.io/kickstart-static64.sh) 简单安装，后期应该会尝试使用别的方式安装，特别是汉化版的安装 邮件配置首先我是直接安装在系统里的，非docker，上面的命令安装时也会打印出你的安装路径 或者在配置文件里也可以看到安装路径 这里安装路径在/opt/netdata/下面，所以官网下文档的命令都要加上这个部分路径前缀 邮件这里使用msmtp，比较简单 首先安装，这里是centos7 1yum install msmtp 一键安装netdata时会自动创建一个用户netdata，邮件配置要在这个用户下做。 12345678910111213141516171819202122232425262728293031#先修改netdata告警配置文件中邮件软件的位置vim /opt/netdata/etc/netdata/health_alarm_notify.conf#修改sendmail的值 原始应该是空的sendmail=&quot;/usr/bin/msmtp&quot;#切换用户su -s /bin/bash netdata#创建配置文件vim ~/.msmtprc#写入以下配置 参考https://marlam.de/msmtp/msmtprc.txtdefaultsport 25tls offaccount freemailhost xxx.xxxfrom kim987@qq.comauth loginuser kim987@qq.compassword xxxxxxxxxxaccount default : freemail#设置权限chmod 600 ~/.msmtprc#测试/opt/netdata/usr/libexec/netdata/plugins.d/alarm-notify.sh test#收到测试文件就成功了","link":"/2021/2021-7-16-2/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"logstash","slug":"logstash","link":"/tags/logstash/"},{"name":"error","slug":"error","link":"/tags/error/"},{"name":"logo","slug":"logo","link":"/tags/logo/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"监控","slug":"监控","link":"/tags/%E7%9B%91%E6%8E%A7/"},{"name":"netdata","slug":"netdata","link":"/tags/netdata/"}],"categories":[{"name":"错误处理","slug":"错误处理","link":"/categories/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"}]}